<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Santê Console</title>
  <link rel="stylesheet" href="/styles.css" />
  <script>(function(){
    try {
      const onLogin = location.pathname.endsWith('/login.html');
      const hasFlag = localStorage.getItem('auth')==='ok';
      // Shim: garantir chave legacy session_id usando sessionId se existir
      try { const sid = localStorage.getItem('sessionId'); if(sid && !localStorage.getItem('session_id')) localStorage.setItem('session_id', sid); } catch {}
      if(onLogin && hasFlag){ location.replace('/'); return; }
      if(!hasFlag){
        // tentativa silenciosa de validar cookie/sessão; se falhar, força login
        fetch('/me/profile',{method:'GET'}).then(r=>{
          if(r.status===401){ if(!onLogin) location.replace('/login.html'); }
          else if(r.ok){ if(onLogin) location.replace('/'); else localStorage.setItem('auth','ok'); }
          else { if(!onLogin) location.replace('/login.html'); }
        }).catch(()=>{ if(!onLogin) location.replace('/login.html'); });
      }
    } catch {}
  })();</script>
</head>
<body>
  <header class="topbar"><div class="topbar-inner">
    <div class="brand">Santê Console</div>
    <nav class="menu" role="navigation" aria-label="Atalhos principais">
  <button type="button" class="m-btn" id="menu-flow" aria-haspopup="dialog">Fluxo IA</button>
      <button type="button" class="m-btn" id="menu-qr" aria-haspopup="dialog">Conectar QR</button>
      <button type="button" class="m-btn" id="menu-schedule" aria-haspopup="dialog">Agendar envios</button>
      <button type="button" class="m-btn" id="menu-tags" aria-haspopup="dialog">Etiquetar mensagem</button>
    </nav>
    <div style="display:flex;align-items:center;gap:8px;margin-left:auto">
      <button type="button" class="m-btn" id="theme-toggle" aria-label="Alternar tema">🌙</button>
      <div class="badge" id="svc-badge">Carregando…</div>
      <button type="button" class="m-btn" id="profile-btn" aria-haspopup="dialog" title="Perfil">👤</button>
    </div>
  </div></header>

  <div class="app" id="app">
    <aside class="sidebar">
      <div class="s-header">
        <div class="brand" style="font-size:15px">Conversas</div>
  <div class="actions"><button type="button" class="icon-btn" id="new-chat" aria-label="Nova conversa">＋</button></div>
      </div>
      <div class="s-search"><input class="input" id="search" placeholder="Pesquisar conversas…"></div>
      <div class="s-filters">
        <button class="chip is-active" data-filter="all">Todos</button>
        <button class="chip" data-filter="unread">Não lidas</button>
        <button class="chip" data-filter="starred">Com estrela</button>
      </div>
      <div class="chat-list" id="chat-list"></div>
    </aside>

    <section class="chat">
      <div class="c-header">
        <div class="peer">
          <button type="button" class="icon-btn" id="back" style="display:none" aria-label="Voltar">←</button>
          <div class="avatar"></div>
          <div class="meta">
            <div class="name" id="peer-name">Selecione uma conversa</div>
            <div class="status" id="online-badge">—</div>
          </div>
        </div>
        <div class="actions">
          <button type="button" class="icon-btn" id="chat-search" aria-label="Buscar na conversa">🔍</button>
          <button type="button" class="icon-btn" id="chat-info" aria-label="Informações da conversa">ℹ️</button>
        </div>
      </div>
      <div class="c-messages" id="messages"></div>
    <form class="c-composer" id="composer">
  <button type="button" class="icon-btn" id="attach" aria-label="Anexar arquivo">📎</button>
  <textarea class="input" id="text" placeholder="Escreva uma mensagem…" aria-label="Mensagem" rows="1" style="resize:none;overflow:hidden"></textarea>
  <button type="submit" class="btn" id="send" aria-label="Enviar mensagem">Enviar</button>
    </form>
    </section>
  </div>

  <!-- Drawer Perfil -->
  <div class="drawer" id="drw-profile">
    <div class="drawer-panel" role="dialog" aria-modal="true" aria-labelledby="profile-title">
      <div class="drawer-h">
        <h3 id="profile-title" style="margin:0">Perfil</h3>
        <button class="icon-btn" data-close-profile aria-label="Fechar">✖</button>
      </div>
      <div class="drawer-b" id="profile-body">
        <div class="section">
          <strong>Usuário:</strong> <span id="pf-user">—</span><br/>
          <strong>Session ID:</strong> <span id="pf-session">—</span>
        </div>
        <div class="section">
          <strong>Plano:</strong> <span id="pf-plan">—</span><br/>
          <small>Uso diário: <span id="pf-usage-today">0</span>/<span id="pf-quota">0</span></small><br/>
          <small>Total: <span id="pf-usage-total">0</span></small>
        </div>
        <div class="section">
          <strong>Sessão WhatsApp:</strong> <span id="pf-state">—</span>
          <div class="help" id="pf-jid" style="margin-top:4px;">—</div>
          <div id="pf-qr-wrap" style="margin-top:6px;display:none"><img id="pf-qr" alt="QR" style="max-width:180px;border:1px solid #222;padding:4px;border-radius:4px"/></div>
          <div class="row" style="gap:6px;margin-top:8px">
            <button class="btn sm" id="btn-regen-qr" style="display:none">Regenerar QR</button>
            <button class="btn sm" id="btn-clean" style="display:none">Desvincular</button>
          </div>
        </div>
      </div>
      <div class="drawer-f" style="display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap;">
        <button class="btn outline" id="btn-logout">Logout</button>
        <button class="btn" data-close-profile>Fechar</button>
      </div>
    </div>
  </div>

  <script>
  // Util toast
  function toast(msg,type='ok'){
    const t=document.createElement('div');
    t.className='toast '+type;
    t.textContent=msg;
    document.body.appendChild(t);
    requestAnimationFrame(()=>t.classList.add('show'));
    setTimeout(()=>{t.classList.remove('show'); setTimeout(()=>t.remove(),200)},2500);
  }

  // Estado dinâmico: chats (Map) e mensagens por JID
  const chatsMap = new Map(); // jid -> { id, name, last, time, unread, starred }
  const messagesByJid = new Map(); // jid -> [ { id,text,fromMe,timestamp } ]
  let activeFilter='all';
  let currentChat=null; // objeto { id, name }
  const app=document.getElementById('app');
  const listEl=document.getElementById('chat-list');
  const messagesEl=document.getElementById('messages');
  const peerName=document.getElementById('peer-name');
  const onlineBadge=document.getElementById('online-badge');
  const backBtn=document.getElementById('back');
  const svcBadge=document.getElementById('svc-badge');
  const textInput=document.getElementById('text');
  const composer=document.getElementById('composer');
  let msgSeq=0; // contador sintético para IDs de mensagens
  const LS_CHAT_KEY='last_chat_id';

  function renderChatList(){
    listEl.innerHTML='';
    const lastId = localStorage.getItem(LS_CHAT_KEY);
    const chatsArr = Array.from(chatsMap.values()).sort((a,b)=> (b.timestamp||0)-(a.timestamp||0));
    chatsArr.filter(c=>{
      if(activeFilter==='unread') return (c.unread||0) > 0;
      if(activeFilter==='starred') return !!c.starred;
      return true;
    }).forEach(c => {
      const item = document.createElement('div');
      item.className='chat-item';
      if(currentChat && currentChat.id===c.id) item.classList.add('is-active');
      if(!currentChat && lastId && lastId===c.id) item.classList.add('is-active');
      const unreadBadge = (c.unread||0) > 0 ? `<span class="unread">${c.unread}</span>` : '';
      const star = `<button class="star-btn" data-star="${c.id}" aria-label="Marcar favorito">${c.starred?'★':'☆'}</button>`;
      item.innerHTML = `<div class="avatar"></div><div class="meta"><div class="name">${c.name||c.id} ${star}</div><div class="last">${escapeHtml(c.last||'')}</div></div><div class="time">${c.time||''} ${unreadBadge}</div>`;
      item.addEventListener('click',(ev)=>{
        const target = ev.target;
        if(target && target.closest && target.closest('.star-btn')) return;
        selectChat(c.id);
      });
      listEl.appendChild(item);
    })
    // estrela toggle
    listEl.querySelectorAll('.star-btn').forEach(btn=>{
      btn.addEventListener('click', function(e){
        e.stopPropagation();
        const id=this.getAttribute('data-star');
        const chat=chatsMap.get(id);
        if(chat){ chat.starred=!chat.starred; renderChatList(); }
      })
    })
  }

  function escapeHtml(t){ return t.replace(/[&<>"]/g,c=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;"}[c]||c)) }

  function selectChat(jid){
    const chat = chatsMap.get(jid);
    if(!chat) return;
    currentChat = chat;
    localStorage.setItem(LS_CHAT_KEY, chat.id);
    chat.unread = 0;
    peerName.textContent = chat.name || chat.id;
    messagesEl.innerHTML='';
    const msgs = messagesByJid.get(jid)||[];
    msgs.sort((a,b)=>a.timestamp-b.timestamp).forEach(m=>pushMsg(m.fromMe?'out':'in', m.text, m.id));
    if(window.matchMedia('(max-width:1023px)').matches){ app.dataset.view='chat'; backBtn.style.display='inline-block'; }
    document.querySelectorAll('.chat-item').forEach(el=>el.classList.remove('is-active'));
    requestAnimationFrame(()=>{
      [...document.querySelectorAll('.chat-item')].find(el=>el.textContent.includes(chat.name||chat.id))?.classList.add('is-active');
    })
    scrollBottom();
    renderChatList(); // atualiza contadores
  }

  function pushMsg(dir,text,id){
    const temp = !id;
    id = id || (Date.now().toString(36)+'-'+(msgSeq++).toString(36));
    const el=document.createElement('div');
    el.className='msg '+(dir==='out'?'out':'in');
    el.setAttribute('data-id', id);
    el.textContent=text;
    if(temp) el.classList.add('pending');
    // etiqueta existente via API (fetch preguiçoso)
    fetch('/tags').then(r=>r.ok?r.json():{tags:{}}).then(j=>{
      const t=j.tags||{}; if(t[id]){ const tagEl=document.createElement('div'); tagEl.className='meta'; tagEl.textContent='#'+t[id]; el.appendChild(tagEl); }
    }).catch(()=>{})
    // menu de contexto para etiquetar
    el.addEventListener('contextmenu', (e)=>{
      e.preventDefault();
      const tagInput = document.getElementById('tag-msg-id');
      if(tagInput) tagInput.value = id;
      show('#mdl-tags');
    });
    messagesEl.appendChild(el);
    scrollBottom();
  }
  function scrollBottom(){ messagesEl.scrollTop=messagesEl.scrollHeight; }

  backBtn.onclick=()=>{
    delete app.dataset.view;
    backBtn.style.display='none';
  };

  // Health status
  async function refreshHealth(){
    try{
      const r=await fetch('/health');
      if(r.ok){svcBadge.textContent='Online';svcBadge.style.background='#0f1a16';svcBadge.style.color='#9be3c2';}
      else {svcBadge.textContent='Offline';svcBadge.style.background='#3a1a1a';svcBadge.style.color='#fca5a5';}
    }catch{svcBadge.textContent='Offline';svcBadge.style.background='#3a1a1a';svcBadge.style.color='#fca5a5';}
  }
  refreshHealth(); setInterval(refreshHealth,15000);

  // Session status polling
  const storedSession=localStorage.getItem('session_id');
  async function pollSession(){
    if(!storedSession) return;
    try{
      const r=await fetch(`/sessions/${encodeURIComponent(storedSession)}/status`);
      if(r.ok){
        const j=await r.json();
        onlineBadge.textContent=j.state==='open' ? (j.jid? `online · ${j.jid}`:'online') : j.state;
      }
    }catch{}
  }
  pollSession(); setInterval(pollSession,5000);

  // Composer send
  composer.addEventListener('submit', async (e)=>{
    e.preventDefault();
    if(!currentChat){ toast('Selecione uma conversa','err'); return; }
    const text=(textInput.value||'').trim();
    if(!text) return;
    const optimisticId = pushMsg('out',text); // retorna undefined, mas mantemos classe pending; iremos reconciliar via SSE
    const payload={ session_id: localStorage.getItem('session_id') || '', to: currentChat.id, text, client_ref: optimisticId };
    textInput.value='';
    autoResize(textInput);
    try{
      const r=await fetch('/messages/send',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(payload)});
      if(!r.ok){ toast('Falha ao enviar','err'); }
    }catch{ toast('Falha ao enviar','err'); }
  });

  // Auto-resize textarea up to a max height (approx 6 lines)
  function autoResize(el){
    if(!el) return; el.style.height='auto';
    const max=140; // px
    const h=Math.min(el.scrollHeight, max);
    el.style.height=h+'px';
    el.style.overflowY = el.scrollHeight>max ? 'auto':'hidden';
  }
  textInput.addEventListener('input',()=>autoResize(textInput));
  autoResize(textInput);

  // Enter to send (desktop style): Enter sends, Shift+Enter newline
  textInput.addEventListener('keydown',(e)=>{
    if(e.key==='Enter' && !e.shiftKey){
      e.preventDefault();
      // Trigger submit programmatically
      composer.requestSubmit();
    }
  });

  // New chat just demonstrates toast
  document.getElementById('new-chat').onclick=()=>toast('Funcionalidade futura');

  // Filter chips
  document.querySelectorAll('.s-filters .chip').forEach(chip=>{
    chip.addEventListener('click',()=>{
      document.querySelectorAll('.s-filters .chip').forEach(c=>c.classList.remove('is-active'));
      chip.classList.add('is-active');
      activeFilter = chip.getAttribute('data-filter')||'all';
      renderChatList();
    });
  });

  // Busca real (debounce)
  const searchInput = document.getElementById('search');
  let searchTimer=null;
  if(searchInput){
    searchInput.addEventListener('input', ()=>{
      clearTimeout(searchTimer);
      const q = searchInput.value.trim();
      if(!q){ renderChatList(); return; }
      searchTimer=setTimeout(()=> runSearch(q), 350);
    });
  }
  async function runSearch(q){
    const sessionId = localStorage.getItem('session_id');
    if(!sessionId) return;
    try{
      const r=await fetch(`/sessions/${encodeURIComponent(sessionId)}/search?q=${encodeURIComponent(q)}`);
      if(!r.ok) return;
      const j=await r.json();
      const hits=(j.results||[]).slice(0,50); // limitar
      // mapear hits a chats e reordenar artificialmente
      const now=Date.now();
      hits.forEach((h,i)=>{
        const jid = h.fromMe? (h.to||h.from): h.from;
        if(!messagesByJid.has(jid)) messagesByJid.set(jid, []);
        // adicionar ghost message se não existir
        if(!messagesByJid.get(jid).some(m=>m.id===h.id)){
          messagesByJid.get(jid).push({ id:h.id, text:h.text||'', fromMe:!!h.fromMe, timestamp:h.timestamp||now });
        }
        let chat = chatsMap.get(jid);
        if(!chat){ chat = { id:jid, name:jid, last:h.text?.slice(0,60)||'', time: formatTime(h.timestamp||now), unread:0, starred:false, timestamp: h.timestamp||now }; chatsMap.set(jid, chat); }
        chat.last = h.text?.slice(0,60)||'';
        chat.timestamp = now + (1000 - i); // força ordenar pelo resultado
        chat.time = formatTime(chat.timestamp);
      });
      renderChatList();
    }catch{}
  }

  // ===== Perfil =====
  const profileBtn=document.getElementById('profile-btn');
  const drwProfile=document.getElementById('drw-profile');
  const pfUser=document.getElementById('pf-user');
  const pfSession=document.getElementById('pf-session');
  const pfPlan=document.getElementById('pf-plan');
  const pfUsageToday=document.getElementById('pf-usage-today');
  const pfQuota=document.getElementById('pf-quota');
  const pfUsageTotal=document.getElementById('pf-usage-total');
  const pfState=document.getElementById('pf-state');
  const pfJid=document.getElementById('pf-jid');
  const pfQRWrap=document.getElementById('pf-qr-wrap');
  const pfQR=document.getElementById('pf-qr');
  const btnRegen=document.getElementById('btn-regen-qr');
  const btnClean=document.getElementById('btn-clean');
  const btnLogout=document.getElementById('btn-logout');

  function showProfile(){ drwProfile.classList.add('show'); loadProfile(); }
  function hideProfile(){ drwProfile.classList.remove('show'); }
  drwProfile?.addEventListener('click', (e)=>{ if(e.target===drwProfile) hideProfile(); });
  document.querySelectorAll('[data-close-profile]').forEach(b=>b.addEventListener('click', hideProfile));
  profileBtn?.addEventListener('click', showProfile);

  let qrPollTimer=null;
  async function pollQR(sessionId){
    clearTimeout(qrPollTimer);
    try {
      const r=await fetch('/me/session/qr');
      if(r.ok){ const j=await r.json(); pfQR.src=j.dataUrl; pfQRWrap.style.display='block'; }
      else if(r.status===404){ pfQRWrap.style.display='none'; }
    }catch{}
    qrPollTimer=setTimeout(()=>pollQR(sessionId), 6000);
  }

  async function loadProfile(){
    try {
      const r=await fetch('/me/profile');
      if(!r.ok){ toast('Falha perfil','err'); return }
      const j=await r.json();
      pfUser.textContent=j.userId;
      pfSession.textContent=j.sessionId;
      pfPlan.textContent=j.plan?.name||'—';
      pfUsageToday.textContent=j.usage?.messagesToday||0;
      pfQuota.textContent=j.plan?.quotaDaily||0;
      pfUsageTotal.textContent=j.usage?.total||0;
      pfState.textContent=j.session?.state||'—';
      if(pfJid){
        if(j.session?.jid){ pfJid.textContent = 'Conectado: '+ j.session.jid; }
        else { pfJid.textContent = 'Não conectado'; }
      }
      // Persistir session_id para garantir que o restante da UI (SSE, envio) tenha a sessão correta
      try {
        if(j.sessionId){
          localStorage.setItem('session_id', j.sessionId);
          // manter chave alternativa (legacy) se algum código usa
          if(!localStorage.getItem('sessionId')) localStorage.setItem('sessionId', j.sessionId);
        }
      } catch {}
      const st=j.session?.state;
      const manual = (window.MANUAL_PAIRING === '1');
      btnRegen.style.display = manual && (st==='pairing' || st==='idle') ? 'inline-block':'none';
      btnClean.style.display = 'inline-block';
      if(st==='pairing'){ pollQR(j.sessionId) } else { pfQRWrap.style.display='none'; clearTimeout(qrPollTimer); }
    } catch {}
  }

  btnRegen?.addEventListener('click', async ()=>{
    btnRegen.disabled=true; try{ const r=await fetch('/me/session/regen-qr',{method:'POST'}); if(r.ok){ toast('Reiniciando sessão'); loadProfile(); } else toast('Erro regen','err'); } finally { btnRegen.disabled=false; }
  });
  btnClean?.addEventListener('click', async ()=>{
    if(!confirm('Desvincular e limpar credenciais?')) return;
    btnClean.disabled=true; try{ const r=await fetch('/me/session/clean',{method:'POST'}); if(r.ok){ toast('Sessão limpa'); loadProfile(); } else toast('Erro limpar','err'); } finally { btnClean.disabled=false; }
  });
  btnLogout?.addEventListener('click', async ()=>{
    try { const r=await fetch('/me/logout',{method:'POST'}); } catch {}
    try { localStorage.removeItem('auth'); localStorage.removeItem('sessionId'); localStorage.removeItem('userId'); } catch {}
    location.replace('/login.html');
  });

  // Attachment button behavior (placeholder)
  const attachBtn=document.getElementById('attach');
  if(attachBtn){
    const fileInput=document.createElement('input');
    fileInput.type='file';
    fileInput.style.display='none';
    document.body.appendChild(fileInput);
    attachBtn.addEventListener('click',()=>fileInput.click());
    fileInput.addEventListener('change', async ()=>{
      if(!(currentChat && fileInput.files && fileInput.files[0])) return;
      const f=fileInput.files[0];
      const sessionId = localStorage.getItem('session_id')||'';
      if(!sessionId){ toast('Sem sessão','err'); return; }
      // placeholder msg
      const placeholderId = pushMsg('out', `📎 Enviando ${f.name}...`);
      const form = new FormData();
      form.append('session_id', sessionId);
      form.append('to', currentChat.id);
      form.append('file', f);
      try{
        const r=await fetch('/messages/media',{method:'POST', body: form});
        if(!r.ok){ toast('Falha upload','err'); }
        else {
          // A mensagem real chegará via SSE; podemos marcar placeholder como enviado
          const el = messagesEl.querySelector(`[data-id="${placeholderId}"]`);
          if(el){ el.classList.remove('pending'); el.textContent = `📎 ${f.name}`; }
        }
      }catch{ toast('Erro rede upload','err'); }
      finally { fileInput.value=''; }
    });
  }

  async function loadInitial(){
    const sessionId = localStorage.getItem('session_id');
    if(!sessionId) return;
    // aguardar até estado open (tentativa leve)
    try {
      const st = await fetch(`/sessions/${encodeURIComponent(sessionId)}/status`).then(r=>r.ok?r.json():null);
      if(!st || st.state!=='open'){ /* não bloqueia, ainda assim tenta buscar novas */ }
    } catch {}
    let data=[]; try { const r=await fetch(`/sessions/${encodeURIComponent(sessionId)}/messages?limit=500`); if(r.ok){ const j=await r.json(); data=j.messages||[] } } catch {}
    // Normalizar e agrupar
    data.forEach(m=>{
      const jid = m.fromMe ? (m.to || m.from) : m.from;
      if(!messagesByJid.has(jid)) messagesByJid.set(jid, []);
      messagesByJid.get(jid).push({ id:m.id, text:m.text||'', fromMe:!!m.fromMe, timestamp:m.timestamp||Date.now() });
    });
    // Construir chats
    messagesByJid.forEach((arr,jid)=>{
      const lastMsg = arr.slice().sort((a,b)=>b.timestamp-a.timestamp)[0];
      chatsMap.set(jid, { id: jid, name: jid, last: lastMsg?.text?.slice(0,60)||'', time: formatTime(lastMsg?.timestamp), unread:0, starred:false, timestamp: lastMsg?.timestamp||0 })
    });
    renderChatList();
    // Restaurar último chat
    const restoreId=localStorage.getItem(LS_CHAT_KEY);
    if(restoreId && chatsMap.has(restoreId)) selectChat(restoreId);
  }

  function formatTime(ts){ if(!ts) return ''; const d=new Date(ts); return d.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'}); }

  loadInitial();
  renderChatList();
  // ====== Tempo real (SSE) - Passo 2 ======
  let evtSource=null;
  let sseRetry=0;
  function startSSE(){
    const sessionId = localStorage.getItem('session_id');
    if(!sessionId){ return; }
    if(evtSource){ evtSource.close(); }
    const url = `/sessions/${encodeURIComponent(sessionId)}/stream`;
    try {
      evtSource = new EventSource(url);
    } catch (e){ console.warn('SSE init falhou', e); scheduleReconnect(); return; }
    evtSource.onopen = ()=>{ sseRetry=0; console.log('SSE aberto'); };
    evtSource.onerror = (e)=>{ console.warn('SSE erro', e); evtSource && evtSource.close(); scheduleReconnect(); };
    evtSource.onmessage = (e)=>{
      if(!e.data) return;
      let payload; try{ payload=JSON.parse(e.data); }catch{return;}
      handleSSE(payload);
    };
  }
  function scheduleReconnect(){
    sseRetry = Math.min(sseRetry+1, 6); // limite ~6 -> backoff ~32s max
    const delay = Math.min(1000 * Math.pow(2, sseRetry), 30000);
    setTimeout(()=>startSSE(), delay);
  }
  function handleSSE(ev){
    if(ev.type==='ready'){ return; }
    if(ev.type==='message'){ // nova mensagem
      const m = ev.message || ev;
      const jid = m.fromMe ? (m.to || m.from) : m.from;
      if(!messagesByJid.has(jid)) messagesByJid.set(jid, []);
      // evitar duplicados
      if(!messagesByJid.get(jid).some(x=>x.id===m.id)){
        messagesByJid.get(jid).push({ id:m.id, text:m.text||'', fromMe:!!m.fromMe, timestamp:m.timestamp||Date.now() });
      }
      // Reconciliação otimista: se mensagem fromMe e possuímos .pending com mesmo texto recente
      if(m.fromMe && currentChat && currentChat.id===jid){
        // procure a última .pending cujo texto combine
        const pendings = [...messagesEl.querySelectorAll('.msg.out.pending')];
        for(let i=pendings.length-1;i>=0;i--){
          const el=pendings[i];
          if(el.textContent=== (m.text||'')){ el.classList.remove('pending'); el.setAttribute('data-id', m.id); break; }
        }
      }
      // atualizar chat
      const arr = messagesByJid.get(jid);
      const lastMsg = arr.slice().sort((a,b)=>b.timestamp-a.timestamp)[0];
      let chat = chatsMap.get(jid);
      if(!chat){ chat = { id:jid, name:jid, last:'', time:'', unread:0, starred:false, timestamp:0 }; chatsMap.set(jid, chat); }
      chat.last = lastMsg?.text?.slice(0,60)||'';
      chat.timestamp = lastMsg?.timestamp||Date.now();
      chat.time = formatTime(chat.timestamp);
      // unread se não está aberto e mensagem é inbound
      if(!(currentChat && currentChat.id===jid) && !m.fromMe){ chat.unread = (chat.unread||0)+1; }
      // se chat aberto, render incremental
      if(currentChat && currentChat.id===jid){
        // só adicionar se não reconciliado (sem elemento com data-id)
        if(!messagesEl.querySelector(`[data-id="${m.id}"]`)){
          pushMsg(m.fromMe?'out':'in', m.text||'', m.id);
        }
      }
      renderChatList();
      return;
    }
    if(ev.type==='message_status'){ // apenas poderia atualizar UI futura (ticks)
      // placeholder: no momento ignorado, mas poderíamos alterar classe visual
      return;
    }
  }
  // iniciar SSE após pequeno atraso para garantir session_id e histórico
  setTimeout(startSSE, 800);
  // ==== Modal utilities & feature mocks ====
  function $(s,root=document){return root.querySelector(s)}
  function show(id){ $(id).classList.add('show') }
  function hide(el){ el.classList.remove('show') }
  document.querySelectorAll('.modal [data-close]')?.forEach(b=>b.addEventListener('click',e=>hide(e.target.closest('.modal'))))

  // Open modals
  $('#menu-flow')?.addEventListener('click', ()=>show('#mdl-flow'))
  $('#menu-qr')?.addEventListener('click', ()=>{ showProfile(); })
  $('#menu-schedule')?.addEventListener('click', ()=>show('#mdl-schedule'))
  $('#menu-tags')?.addEventListener('click', ()=>show('#mdl-tags'))

  // ====== Nova lógica QR ======
  function getSessionId(){ return localStorage.getItem('sessionId') || localStorage.getItem('session_id') || '' }
  // Reuso de variáveis globais se já definidas anteriormente
  if(typeof qrPollTimer==='undefined'){ window.qrPollTimer=null; }
  let qrStatusTimer=null;
  function clearQRTimers(){ if(qrPollTimer) clearTimeout(qrPollTimer); if(qrStatusTimer) clearTimeout(qrStatusTimer); }
  async function fetchStatus(id){ try{ const r=await fetch(`/sessions/${encodeURIComponent(id)}/status`); if(!r.ok) return null; return await r.json(); }catch{ return null } }
  async function fetchQR(){ try{ const r=await fetch('/me/session/qr'); if(!r.ok) return null; const j=await r.json(); return j.dataUrl }catch{ return null } }
  async function ensureSessionCreated(id){ try { await fetch('/sessions/create',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({session_id:id})}) } catch {} }
  async function startManual(id){ try { const r=await fetch(`/sessions/${encodeURIComponent(id)}/start`,{method:'POST'}); return r.ok } catch { return false } }
  function setQRState(s){ const el=document.getElementById('qr-state'); if(el) el.textContent=s||'—'; }
  function showEl(id,show){ const el=document.getElementById(id); if(el) el.style.display=show? 'block':'none'; }
  async function pollQRImage(){ const imgEl=document.getElementById('qr-image'); const wrap=document.getElementById('qr-image-wrap'); if(!imgEl||!wrap) return; const code=await fetchQR(); if(code){ imgEl.src=code; wrap.style.display='block'; } else { wrap.style.display='none'; } qrPollTimer=setTimeout(pollQRImage,6000); }
  async function pollStatusLoop(){ const id=getSessionId(); if(!id) return; const st=await fetchStatus(id); if(st){ setQRState(st.state); updateQRUIForState(st.state); } qrStatusTimer=setTimeout(pollStatusLoop,5000); }
  function updateQRUIForState(state){ const connected=document.getElementById('qr-connected'); const imgWrap=document.getElementById('qr-image-wrap'); const btnStart=document.getElementById('qr-start'); const btnRegen=document.getElementById('qr-regen'); const btnClean=document.getElementById('qr-clean'); const btnOpenTab=document.getElementById('qr-open-newtab'); const manual = window.MANUAL_PAIRING==='1';
    if(state==='open'){ connected.style.display='block'; imgWrap.style.display='none'; btnStart.style.display='none'; btnRegen.style.display= manual? 'inline-block':'none'; btnClean.style.display='inline-block'; btnOpenTab.style.display='none'; clearTimeout(qrPollTimer); }
    else if(state==='pairing'){ connected.style.display='none'; btnStart.style.display='none'; btnRegen.style.display= manual? 'inline-block':'none'; btnClean.style.display='inline-block'; btnOpenTab.style.display='inline-block'; pollQRImage(); }
    else { // idle / closed / undefined
      connected.style.display='none'; imgWrap.style.display='none'; btnRegen.style.display='none'; btnOpenTab.style.display='none'; btnClean.style.display='inline-block'; btnStart.style.display= manual? 'inline-block':'none'; if(!manual){ // auto criar
          const id=getSessionId(); if(id){ ensureSessionCreated(id); }
        }
    }
  }
  async function openQRModal(){ const modal=document.getElementById('mdl-qr'); if(!modal) return; modal.classList.add('show'); clearQRTimers(); const id=getSessionId(); if(!id){ setQRState('sem sessão'); return; } setQRState('carregando...'); const prof = await fetch('/me/profile').then(r=>r.ok?r.json():null).catch(()=>null); const state = prof?.session?.state; if(!state){ await ensureSessionCreated(id); }
    updateQRUIForState(state||'idle'); pollStatusLoop(); if(state==='pairing'){ pollQRImage(); } }
  document.getElementById('qr-start')?.addEventListener('click', async ()=>{ const id=getSessionId(); if(!id) return toast('Sem sessão','err'); const ok=await startManual(id); if(!ok) return toast('Falha iniciar','err'); setQRState('pairing'); updateQRUIForState('pairing'); pollQRImage(); })
  document.getElementById('qr-regen')?.addEventListener('click', async ()=>{ const id=getSessionId(); if(!id) return; await fetch(`/sessions/${encodeURIComponent(id)}/qr/regenerate`,{method:'POST'}).catch(()=>{}); toast('Solicitado novo QR'); })
  document.getElementById('qr-clean')?.addEventListener('click', async ()=>{ await fetch('/me/session/clean',{method:'POST'}).catch(()=>{}); toast('Sessão limpa'); clearQRTimers(); setQRState('idle'); updateQRUIForState('idle'); })
  document.getElementById('qr-open-newtab')?.addEventListener('click', ()=>{ const id=getSessionId(); if(!id) return; window.open(`/qr.html?session_id=${encodeURIComponent(id)}`,'_blank'); })

  // === Flows (API) ===
  async function createFlow(){
    const name = $('#flow-name')?.value?.trim()||'Fluxo'
    let nodes; try{ nodes = JSON.parse($('#flow-json')?.value || '[]') }catch{ return toast('JSON inválido','err') }
    try {
      const r=await fetch('/flows',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({name,nodes})})
      if(!r.ok) return toast('Erro ao salvar fluxo','err')
      toast('Fluxo salvo'); hide($('#mdl-flow'))
    } catch { toast('Erro rede','err') }
  }
  $('#flow-save')?.addEventListener('click', createFlow)

  // === Schedules (API) ===
  async function fetchSchedules(){
    try{ const r=await fetch('/schedules'); if(!r.ok) return []; const j=await r.json(); return j.schedules||[] }catch{return []}
  }
  async function renderSchedules(){ const box = $('#sched-list'); if(!box) return; const arr = await fetchSchedules(); box.innerHTML = arr.length? arr.map(s=>`• ${new Date(s.when).toLocaleString()} → ${s.to}: "${s.text}" <span style='opacity:.6'>(${s.status})</span>`).join('<br>') : 'Sem agendamentos.' }
  renderSchedules()
  $('#sched-save')?.addEventListener('click', async ()=>{
  const session_id = localStorage.getItem('sessionId') || localStorage.getItem('session_id') || ''
    const to = $('#sched-to')?.value?.trim()
    const text = $('#sched-text')?.value?.trim()
    const when = $('#sched-when')?.value
    if(!session_id||!to||!text||!when) return toast('Preencha todos os campos','err')
    try{
      const r=await fetch('/schedules',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({session_id,to,text,when})})
      if(!r.ok) return toast('Erro ao agendar','err')
      toast('Agendado')
      renderSchedules()
    }catch{ toast('Erro rede','err') }
  })

  // === Tags (API) ===
  async function fetchTags(){ try{ const r=await fetch('/tags'); if(!r.ok) return {}; const j=await r.json(); return j.tags||{} }catch{return {}} }
  async function renderTags(){ const box = $('#tag-list'); if(!box) return; const t = await fetchTags(); box.innerHTML = Object.keys(t).length? Object.entries(t).map(([k,v])=>`• ${k}: ${v}`).join('<br>') : 'Sem etiquetas.' }
  renderTags()
  $('#tag-save')?.addEventListener('click', async ()=>{
    const id = $('#tag-msg-id')?.value?.trim()
    const label = $('#tag-label')?.value?.trim()
    if(!id||!label) return toast('Informe id e etiqueta','err')
    try {
      const r=await fetch('/tags',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({message_id:id,label})})
      if(!r.ok) return toast('Erro ao etiquetar','err')
      toast('Etiqueta aplicada'); renderTags();
    } catch { toast('Erro rede','err') }
  })

  // toast util fallback
  if(typeof toast!=='function'){
    window.toast = function(msg,type='ok'){
      const t=document.createElement('div');t.className='toast '+type; t.textContent=msg; document.body.appendChild(t);
      requestAnimationFrame(()=>t.classList.add('show')); setTimeout(()=>{t.classList.remove('show'); setTimeout(()=>t.remove(),200)},2500)
    }
  }

  // === Theme Toggle ===
  (function(){
    const btn=document.getElementById('theme-toggle');
    if(!btn) return;
    const root=document.documentElement;
    const KEY='theme_pref';
    function apply(t){ if(t==='light'){ root.setAttribute('data-theme','light'); btn.textContent='🌙'; btn.setAttribute('aria-label','Usar tema escuro'); } else { root.removeAttribute('data-theme'); btn.textContent='☀️'; btn.setAttribute('aria-label','Usar tema claro'); } }
    let pref=localStorage.getItem(KEY);
    if(!pref){
      // auto detect system
      pref=window.matchMedia('(prefers-color-scheme: light)').matches? 'light':'dark';
    }
    apply(pref);
    btn.addEventListener('click',()=>{
      pref = (root.getAttribute('data-theme')==='light')? 'dark':'light';
      localStorage.setItem(KEY,pref);
      apply(pref);
    });
  })();
  </script>

  <!-- Fluxo IA -->
  <div class="modal" id="mdl-flow">
    <div class="modal-card">
      <div class="modal-h"><strong>Fluxo IA</strong><button class="m-btn" data-close>✕</button></div>
      <div class="modal-b">
        <div style="display:flex;gap:8px;margin-bottom:12px;flex-wrap:wrap" id="flow-tabs">
          <button type="button" class="chip is-active" data-tab="chatbot">Criar Chatbot</button>
          <button type="button" class="chip" data-tab="iaform">Formulário IA</button>
        </div>
        <div id="tab-chatbot">
          <p class="help">Defina sequência de perguntas e respostas do chatbot (estrutura simples).</p>
          <div class="row"><span class="label">Nome</span><input class="input" id="cb-name" placeholder="Ex. Recepção"></div>
          <div class="row" style="align-items:flex-start"><span class="label">Blocos</span>
            <div style="flex:1" id="cb-blocks"></div>
          </div>
          <button type="button" class="m-btn" id="cb-add">Adicionar bloco</button>
          <div class="help">Cada bloco: pergunta feita ao cliente e resposta padrão ou próxima ação.</div>
        </div>
        <div id="tab-iaform" style="display:none">
          <p class="help">Texto base usado pela IA antes de responder. Complementa a Base de Conhecimento.</p>
          <textarea class="input" id="ia-free" rows="10" placeholder="Insira informações adicionais do negócio..."></textarea>
          <div class="help">Salve para atualizar o contexto. Use este campo para campanhas, políticas temporárias etc.</div>
        </div>
      </div>
      <div class="modal-f" id="flow-actions">
        <button class="m-btn" data-close>Fechar</button>
        <button class="btn" id="flow-save">Salvar</button>
      </div>
    </div>
  </div>

  <!-- Conectar QR (reutiliza sessão existente) -->
  <div class="modal" id="mdl-qr">
    <div class="modal-card">
      <div class="modal-h"><strong>Conectar QR</strong><button class="m-btn" data-close>✕</button></div>
      <div class="modal-b" style="display:flex;flex-direction:column;gap:12px;">
        <div>Estado: <span id="qr-state">—</span></div>
        <div id="qr-connected" style="display:none;color:#69e4a6;font-weight:600;">Sessão conectada ✅</div>
        <div id="qr-image-wrap" style="display:none;text-align:center;">
          <img id="qr-image" alt="QR" style="max-width:240px;border:1px solid var(--wa-border);padding:6px;border-radius:8px;background:var(--wa-panel)" />
          <p class="help" style="margin-top:6px;">Escaneie no WhatsApp para conectar.</p>
        </div>
        <div class="help" id="qr-hint">A sessão é ligada ao seu usuário. Reabrir este modal mostra o status atual.</div>
      </div>
      <div class="modal-f" style="display:flex;flex-wrap:wrap;gap:8px;justify-content:space-between;align-items:center;">
        <div style="display:flex;gap:8px;flex-wrap:wrap;">
          <button class="btn" id="qr-start" style="display:none;">Iniciar sessão</button>
          <button class="btn outline" id="qr-regen" style="display:none;">Regenerar QR</button>
          <button class="btn outline" id="qr-open-newtab" style="display:none;">Abrir em aba</button>
        </div>
        <div style="display:flex;gap:8px;flex-wrap:wrap;">
          <button class="btn outline" id="qr-clean" style="display:none;">Desvincular</button>
          <button class="m-btn" data-close>Fechar</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Agendar envios -->
  <div class="modal" id="mdl-schedule">
    <div class="modal-card">
      <div class="modal-h"><strong>Agendar envios</strong><button class="m-btn" data-close>✕</button></div>
      <div class="modal-b">
        <div class="row"><span class="label">Session ID</span><input class="input" id="sched-session" placeholder="Ex. santemoda-01"></div>
        <div class="row"><span class="label">Para (JID)</span><input class="input" id="sched-to" placeholder="5511999999999@s.whatsapp.net"></div>
        <div class="row"><span class="label">Mensagem</span><input class="input" id="sched-text" placeholder="Texto da campanha"></div>
        <div class="row"><span class="label">Quando</span><input class="input" id="sched-when" type="datetime-local"></div>
        <div class="help">Mock local: salva no localStorage e executa no horário via setTimeout (enquanto a página estiver aberta).</div>
        <div id="sched-list" class="help"></div>
      </div>
      <div class="modal-f"><button class="m-btn" data-close>Fechar</button><button class="btn" id="sched-save">Agendar</button></div>
    </div>
  </div>

  <!-- Etiquetar mensagem -->
  <div class="modal" id="mdl-tags">
    <div class="modal-card">
      <div class="modal-h"><strong>Etiquetar mensagem</strong><button class="m-btn" data-close>✕</button></div>
      <div class="modal-b">
        <div class="row"><span class="label">ID da msg</span><input class="input" id="tag-msg-id" placeholder="ex. key.id"></div>
        <div class="row"><span class="label">Etiqueta</span><input class="input" id="tag-label" placeholder="Prioridade, VIP, Suporte..."></div>
        <div class="help">Mock: vamos manter um map de etiquetas em localStorage (msgId -> tag).</div>
        <div id="tag-list" class="help"></div>
      </div>
      <div class="modal-f"><button class="m-btn" data-close>Fechar</button><button class="btn" id="tag-save">Aplicar etiqueta</button></div>
    </div>
  </div>

  <!-- Late binding script to ensure modal elements exist -->
  <script>
  (function(){
    // Re-bind close buttons with event delegation (in case initial binding missed due to DOM order)
    document.addEventListener('click', (e)=>{
      const t = e.target;
      if(t && t.matches && t.matches('.modal [data-close]')){
        const modal = t.closest('.modal');
        if(modal) modal.classList.remove('show');
      }
    });

    // Safe query helper (JS only)
  function $(s, r){ return (r||document).querySelector(s); }

    // If earlier listeners failed (elements absent), attach now.
    $('#qr-open')?.getAttribute('data-bound') || $('#qr-open')?.addEventListener('click', async ()=>{
      const el = $('#qr-session');
      const id = localStorage.getItem('sessionId') || localStorage.getItem('session_id') || '';
      if(!id) return toast('Faça login antes','err');
      try {
        await fetch('/sessions/create',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({session_id:id})});
        window.open(`/qr.html?session_id=${encodeURIComponent(id)}`,'_blank');
      } catch { toast('Erro ao criar sessão','err'); }
    });

    $('#flow-save')?.getAttribute('data-bound') || $('#flow-save')?.addEventListener('click', async ()=>{
      // Determine active tab
      const activeTab = document.querySelector('#flow-tabs .chip.is-active')?.getAttribute('data-tab');
      if(activeTab==='chatbot'){
        const nameEl = document.getElementById('cb-name');
        const name = nameEl && nameEl.value ? nameEl.value.trim() : 'Fluxo';
        // Collect blocks
        const blocks = [];
        document.querySelectorAll('.cb-block').forEach((blk,i)=>{
          const qEl = blk.querySelector('[data-q]');
          const aEl = blk.querySelector('[data-a]');
          const q = qEl && qEl.value ? qEl.value.trim() : '';
          const a = aEl && aEl.value ? aEl.value.trim() : '';
          if(q||a){ blocks.push({ id:'b'+i, question:q||'', answer:a||'' }) }
        });
        try{
          const r=await fetch('/flows',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({name,nodes:blocks})});
          if(!r.ok) return toast('Erro ao salvar fluxo','err');
          toast('Fluxo salvo');
          if(nameEl) nameEl.value='';
          const blkWrap = document.getElementById('cb-blocks');
          if(blkWrap) blkWrap.innerHTML='';
        }catch{ toast('Erro rede','err') }
      } else if(activeTab==='iaform') {
        const extraEl = document.getElementById('ia-free');
        const extra = extraEl && extraEl.value ? extraEl.value : '';
        // Merge with existing knowledge file (append at end under heading)
        try {
          const k= await fetch('/knowledge');
          const base = k.ok? (await k.json()).content : '';
          let updated = base;
          const marker = '\n\n# Extra IA';
          if(base.includes('# Extra IA')){
            updated = base.replace(/(# Extra IA[\s\S]*)$/,'# Extra IA\n'+extra.trim()+"\n");
          } else {
            updated = base.trim()+ marker + '\n'+ extra.trim()+'\n';
          }
          const r=await fetch('/knowledge',{method:'PUT',headers:{'Content-Type':'application/json'},body:JSON.stringify({content:updated})});
          if(!r.ok) return toast('Erro ao salvar IA','err');
          toast('Contexto IA salvo');
        }catch{ toast('Erro rede','err') }
      }
    });

    $('#sched-save')?.getAttribute('data-bound') || $('#sched-save')?.addEventListener('click', async ()=>{
      const sEl=$('#sched-session'); const toEl=$('#sched-to'); const txtEl=$('#sched-text'); const whenEl=$('#sched-when');
      const session_id = (sEl && sEl.value ? sEl.value.trim() : '') || localStorage.getItem('session_id') || '';
      const to = toEl && toEl.value ? toEl.value.trim() : '';
      const text = txtEl && txtEl.value ? txtEl.value.trim() : '';
      const when = whenEl && whenEl.value ? whenEl.value : '';
      if(!session_id||!to||!text||!when) return toast('Preencha todos os campos','err');
      try{ const r=await fetch('/schedules',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({session_id,to,text,when})}); if(!r.ok) return toast('Erro ao agendar','err'); toast('Agendado'); }catch{ toast('Erro rede','err') }
    });

    $('#tag-save')?.getAttribute('data-bound') || $('#tag-save')?.addEventListener('click', async ()=>{
      const idEl=$('#tag-msg-id'); const labelEl=$('#tag-label');
      const id = idEl && idEl.value ? idEl.value.trim() : '';
      const label = labelEl && labelEl.value ? labelEl.value.trim() : '';
      if(!id||!label) return toast('Informe id e etiqueta','err');
      try{ const r=await fetch('/tags',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({message_id:id,label})}); if(!r.ok) return toast('Erro ao etiquetar','err'); toast('Etiqueta aplicada'); }catch{ toast('Erro rede','err') }
    });

    // Menu open bindings safeguard (in case earlier script ran too early somehow)
    $('#menu-flow')?.addEventListener('click', ()=>$('#mdl-flow')?.classList.add('show'))
  $('#menu-qr')?.addEventListener('click', showProfile)
    $('#menu-schedule')?.addEventListener('click', ()=>$('#mdl-schedule')?.classList.add('show'))
    $('#menu-tags')?.addEventListener('click', ()=>$('#mdl-tags')?.classList.add('show'))

    // Tabs handling
    const tabs=document.getElementById('flow-tabs');
    tabs?.addEventListener('click',(e)=>{
      const t=e.target;
      if(!(t && t.closest)) return;
      const chip = t.closest('.chip');
      if(!chip) return;
      tabs.querySelectorAll('.chip').forEach(c=>c.classList.remove('is-active'));
      chip.classList.add('is-active');
      const tab = chip.getAttribute('data-tab');
      const tabChat = document.getElementById('tab-chatbot');
      const tabIA = document.getElementById('tab-iaform');
      if(tabChat) tabChat.style.display = tab==='chatbot'? 'block':'none';
      if(tabIA) tabIA.style.display = tab==='iaform'? 'block':'none';
      if(tab==='iaform') loadIAExtra();
    });

    // Chatbot block builder
    function addBlock(q='',a=''){
      const wrap=document.createElement('div');
      wrap.className='cb-block';
      wrap.style.cssText='border:1px solid var(--wa-border);padding:10px;border-radius:10px;margin-bottom:8px;display:flex;flex-direction:column;gap:6px;background:var(--wa-panel)';
      wrap.innerHTML=`<input data-q class="input" placeholder="Pergunta" value="${q}" />\n<textarea data-a class="input" rows="2" placeholder="Resposta"></textarea>\n<button type="button" class="m-btn cb-del">Remover</button>`;
      const del = wrap.querySelector('.cb-del'); if(del) del.addEventListener('click',()=>wrap.remove());
      const ans = wrap.querySelector('[data-a]'); if(ans) ans.value=a;
      const blocksContainer=document.getElementById('cb-blocks');
      if(blocksContainer) blocksContainer.appendChild(wrap);
    }
    document.getElementById('cb-add')?.addEventListener('click',()=>addBlock());

    // Load IA extra section into textarea
    async function loadIAExtra(){
      try{
        const r=await fetch('/knowledge'); if(!r.ok) return;
        const j=await r.json();
        const match = j.content.match(/# Extra IA[\r\n]+([\s\S]*)$/);
        const iaFree = document.getElementById('ia-free');
        if(iaFree) iaFree.value = match? match[1].trim():'';
      }catch{}
    }
  })();
  </script>
</body>
</html>